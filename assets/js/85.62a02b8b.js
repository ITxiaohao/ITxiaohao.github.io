(window.webpackJsonp=window.webpackJsonp||[]).push([[85],{387:function(t,n,v){"use strict";v.r(n);var _=v(2),r=Object(_.a)({},function(){var t=this,n=t.$createElement,v=t._self._c||n;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("p",[t._v("参考 "),v("strong",[t._v("GitHub")]),t._v(" 上 "),v("strong",[t._v("5W")]),t._v(" "),v("strong",[t._v("star")]),t._v(" 的 "),v("a",{attrs:{href:"https://github.com/trekhleb/javascript-algorithms",target:"_blank",rel:"noopener noreferrer"}},[t._v("javascript-algorithms"),v("OutboundLink")],1),t._v(" 数据结构与算法项目以及多种资料，加上自己理解并记录整理，有对应的源码地址，本系列中出现的所有测试一律使用 "),v("a",{attrs:{href:"https://jestjs.io/",target:"_blank",rel:"noopener noreferrer"}},[t._v("jest"),v("OutboundLink")],1),t._v(" 进行测试，对 jest 不熟悉的朋友也可以看我总结的 "),v("router-link",{attrs:{to:"/passages/automated-testing-learn-introduction/"}},[t._v("jest 系列")])],1),t._v(" "),v("h4",{attrs:{id:"复杂度分析"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#复杂度分析","aria-hidden":"true"}},[t._v("#")]),t._v(" 复杂度分析")]),t._v(" "),v("p",[t._v("20 个最常用的、最基础数据结构与算法，数组、链表、栈、队列、散列表、二叉树、堆、跳表、图、Trie 树、递归、排序、二分查找、搜索、哈希算法、贪心算法、分治算法、回溯算法、动态规划、字符串匹配算法。")]),t._v(" "),v("p",[t._v("时间复杂度与"),v("strong",[t._v("常量")]),t._v("无关，比如 "),v("strong",[t._v("100")]),t._v("，"),v("strong",[t._v("10000")]),t._v(" 这种，只会随着常量的增加，执行效率和时间逐渐增加，跟 "),v("strong",[t._v("n")]),t._v(" 并没有什么关联")]),t._v(" "),v("p",[t._v("一个 for 循环是 O(n) 两个 for 循环嵌套就是 O(n^2)")]),t._v(" "),v("p",[t._v("加法法则：取最大的时间复杂度")]),t._v(" "),v("p",[t._v("乘法法则：嵌套代码的复杂度等于嵌套内外代码的乘积，比如有个嵌套是 O(n)，一个是 O(n^2) 那么他们总的嵌套复杂度是 O(n^3)")]),t._v(" "),v("p",[t._v("只要代码的执行时间不随 n 的增大而增长，这样代码的时间复杂度我们都记作 O(1)")]),t._v(" "),v("p",[t._v("一般情况下，只要算法中不存在循环语句、递归语句，即使有成千上万行的代码，其时间复杂度也是 Ο(1)")]),t._v(" "),v("p",[t._v("复杂度分析法则\n1）单段代码看高频：比如循环。\n2）多段代码取最大：比如一段代码中有单循环和多重循环，那么取多重循环的复杂度。\n3）嵌套代码求乘积：比如递归、多重循环等\n4）多个规模求加法：比如方法有两个参数控制两个循环的次数，那么这时就取二者复杂度相加。")]),t._v(" "),v("p",[t._v("四、常用的复杂度级别？")]),t._v(" "),v("p",[t._v("多项式阶：随着数据规模的增长，算法的执行时间和空间占用，按照多项式的比例增长。包括，\nO (1)（常数阶）、O (logn)（对数阶）、O (n)（线性阶）、O (nlogn)（线性对数阶）、O (n^2)（平方阶）、O (n^3)（立方阶）")]),t._v(" "),v("p",[t._v("非多项式阶：随着数据规模的增长，算法的执行时间和空间占用暴增，这类算法性能极差。包括，\nO (2^n)（指数阶）、O (n!)（阶乘阶）")]),t._v(" "),v("p",[t._v("只要代码的执行时间不随 n 的增大而增长，这样代码的时间复杂度我们集作 O (1)\n不同数据规模，无法评估 m 和 n 的量级大，所以不能利用加法法则，去掉某一个，而是 O (m+n)")]),t._v(" "),v("p",[t._v("空间复杂度：表示算法的存储空间与数据规模之间的增加关系")]),t._v(" "),v("p",[t._v("一、复杂度分析的 4 个概念")]),t._v(" "),v("ol",[v("li",[t._v("最坏情况时间复杂度：代码在最理想情况下执行的时间复杂度。")]),t._v(" "),v("li",[t._v("最好情况时间复杂度：代码在最坏情况下执行的时间复杂度。")]),t._v(" "),v("li",[t._v("平均时间复杂度：用代码在所有情况下执行的次数的加权平均值表示。")]),t._v(" "),v("li",[t._v("均摊时间复杂度：在代码执行的所有复杂度情况中绝大部分是低级别的复杂度，个别情况是高级别复杂度且发生具有时序关系时，可以将个别高级别复杂度均摊到低级别复杂度上。"),v("strong",[t._v("基本上均摊结果就等于低级别复杂度")])])])])},[],!1,null,null,null);n.default=r.exports}}]);